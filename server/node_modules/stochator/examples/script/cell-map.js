var CellMap = (function() {
    CellMap.prototype.updateCells = function() {
        var _this = this;
        var setCellData = function(d, i) {
            return "M" + _this.polygons[i].join("L") + "Z";
        };
        var setCellFill = function(d, i) {
            return _this.cellTypes[i].color;
        };
        var setSiteX = function(d, i) { return _this.centroids[i][0]; };
        var setSiteY = function(d, i) { return _this.centroids[i][1]; };

        var svg = d3.select("svg#diagram");
        var g = svg.selectAll("g.cell-group").data(_this.centroids);

        if (!g.node()) {
            g.enter().append("svg:g")
                .attr("class", "cell-group");

            g.append("svg:path").attr("class", "cell")
                .attr("d", setCellData)
                .style("fill", setCellFill);

            g.append("svg:circle")
                .attr("class", "site")
                .attr("r", 3)
                .attr("cx", setSiteX)
                .attr("cy", setSiteY);

        } else {
            svg.selectAll("path.cell").data("d", setCellData);
            svg.selectAll("circle.site")
                .attr("cx", setSiteX)
                .attr("cy", setSiteY);
        }
    };
    CellMap.prototype.updateEdges = function() {
        var svg = d3.select("svg#diagram");
        var group = svg.select("g.delaunay-triangle");
        if (!group.node()) {
            group = svg.append("svg:g")
                .attr("class", "delaunay-triangle");
        }
        var lines = group.selectAll("line").data(this.edges);
        lines.exit().remove();
        lines.enter().append("line");
        lines
            .attr("class", "delaunay-edge")
            .attr("x1", function(d) { return d[0][0]; })
            .attr("y1", function(d) { return d[0][1]; })
            .attr("x2", function(d) { return d[1][0]; })
            .attr("y2", function(d) { return d[1][1]; });
    };
    CellMap.prototype.draw = function() {
        this.initializeSvg();
        this.updateCells();
    };

    CellMap.prototype.CELL_TYPES = {
        'ocean': { 'name': 'ocean', 'color': '#00A' },
        'lake': { 'name': 'lake', 'color': '#14D' },
        'gulf': { 'name': 'gulf', 'color': '#03C' },
        'land': { 'name': 'land', 'color': '#062' },
        'continental': { 'name': 'continental', 'color': '#051' },
        'island': { 'name': 'island', 'color': '#364' }
    };

    CellMap.prototype.getInitialCellTypes = function() {
        var adjustmentProbability = { kind: 'float' };
        var cellTypeGenerator = new Stochator(adjustmentProbability);
        var cellTypes = cellTypeGenerator.next(this.cellCount);
        return cellTypes.map(function(adjustmentProbability, index) {
            var centrality = this.getCentrality(index);
            if (centrality > adjustmentProbability) return this.CELL_TYPES.land;
            return this.CELL_TYPES.ocean;
        }, this);
    };

    CellMap.prototype.adjustCellsByNeighbors = function(cellTypes) {
        var adjustmentProbability = { kind: 'float' };
        var adjuster = function(cellType, index) {
            var cellTypeGenerator = new Stochator({
                kind: 'set',
                values: this.getNeighborCellTypes(index, cellTypes)
            });
            cellTypes[index] = cellTypeGenerator.next();
        };
        var adjustedSet = this.getRandomCells(this.cellCount / 3);
        var adjustedSetCellTypes = adjustedSet.map(this.cellTypeGetter(cellTypes));
        adjustedSetCellTypes.forEach(adjuster, this);
        return cellTypes;
    };

    CellMap.prototype.getNeighborCellTypes = function(index, cellTypes) {
        var getCellType = this.cellTypeGetter(cellTypes);
        return this.getEdge(index).map(getCellType);
    }

    CellMap.prototype.cellTypeGetter = function(cellTypes) {
        return function(index) {
            return cellTypes[index];
        };
    };

    CellMap.prototype.adjustCellsByGeography = function(cellTypes) {
        var isOcean = function(cellType) { return cellType.name == 'ocean' };
        var isContinental = function(cellType) { return cellType.name == 'continental' };
        cellTypes.forEach(function(cellType, index) {
            var isEdgeCell = this.isEdgePolygon(this.polygons[index]);
            var neighborCellTypes = this.getNeighborCellTypes(index, cellTypes);
            var neighborCounts = {};
            neighborCellTypes.forEach(function(cellType) {
                neighborCounts[cellType.name] = neighborCounts[cellType.name] || 0;
                neighborCounts[cellType.name] += 1;
            });
            if (cellType.name == 'ocean') {
                if (isEdgeCell) {
                    cellTypes[index] = this.CELL_TYPES.ocean;
                } else if (!neighborCounts.ocean || neighborCounts.continental ||
                    neighborCounts.lake) {
                    cellTypes[index] = this.CELL_TYPES.lake;
                }
            } else if (cellType.name == 'land') {
                if (isEdgeCell) {
                    cellTypes[index] = this.CELL_TYPES.ocean;
                } else if (!neighborCounts.ocean) {
                    cellTypes[index] = this.CELL_TYPES.continental;
                } else if (!neighborCounts.land || neighborCounts.land == 1) {
                    cellTypes[index] = this.CELL_TYPES.island;
                }
            }
        }, this);
        return cellTypes;
    };

    CellMap.prototype.getCellTypes = function() {
        var cellTypes = this.getInitialCellTypes();
        cellTypes = this.adjustCellsByNeighbors(cellTypes);
        cellTypes = this.adjustCellsByGeography(cellTypes);
        cellTypes = this.adjustCellsByGeography(cellTypes);
        return cellTypes;
    };

    CellMap.prototype.getEdge = function(index) {
        var indexString = index + '';
        return this.edges
            .map(function(indicesString) { return indicesString.split(','); })
            .filter(function(indices) { return indices.indexOf(indexString) > -1; })
            .map(function(indices) {
                return indices[indices.indexOf(indexString) ? 0 : 1];
            });
    };

    CellMap.prototype.getEdges = function() {
        var edges = d3.map();
        var _this = this;
        this.vertices.forEach(function(point, centroids) {
            for (var i = 0; i < centroids.length; i++) {
                for (var j = i + 1; j < centroids.length; j++) {
                    var centroidPair = [centroids[i], centroids[j]];
                    if (!edges.get(centroidPair)) {
                        edges.set(centroidPair, true);
                    }
                }
            }
        });
        return edges.keys();
    };

    CellMap.prototype.getVertices = function(initialPolygons) {
        var vertices = d3.map();
        initialPolygons.forEach(function(polygon, polygonIndex) {
            polygon.forEach(function(vertex) {
                var value = vertices.get(vertex) || [];
                value.push(polygonIndex);
                vertices.set(vertex, value);
            });
        });
        return vertices;
    };

    CellMap.prototype.getCentroids = function(initialPolygons) {
        return initialPolygons.map(Util.Geom.polygonCentroid);
    };

    CellMap.prototype.getCentrality = function(index) {
        var centroid = this.getCentroid(index);
        var center = [this.width / 2, this.height / 2];
        var centrality = centroid.map(function(coord, index) {
            var distance = Math.abs(coord - center[index]);
            return 1 - distance / center[index];
        });
        return centrality[0] * centrality[1];
    };

    CellMap.prototype.relaxPolygonVertices = function(initialPolygons, initialVertices) {
        return initialPolygons.map(function(polygon) {
            return polygon.map(function(coord) {
                if (this.isEdgePoint(coord)) return coord;
                var points = initialVertices.get(coord).map(this.getCentroid, this);
                return Util.Geom.pointMean(points);
            }, this);
        }, this);
    };

    CellMap.prototype.initializeSvg = function() {
        return d3.select("div#container").insert("svg:svg", "h2")
            .attr("id", "diagram")
            .attr("width", this.width)
            .attr("height", this.height);
    };

    CellMap.prototype.getVoronoiPolygons = function() {
        var points = this.getPoints();
        return d3.geom.voronoi(points)
            .map(this.mask.clip)
            .map(Util.Geom.pointRound)
            .filter(function(polygon) { return polygon.length > 0; });
    };

    CellMap.prototype.relaxPoints = function(points, times) {
        d3.range(times).forEach(function() {
            points = d3.geom.voronoi(points)
                .map(this.mask.clip, this)
                .map(Util.Geom.polygonCentroid);
        }, this);
        return points;
    };

    CellMap.prototype.getSeedPoints = function() {
        var xOrd = { min: 0, max: this.width, kind: 'integer' };
        var yOrd = { min: 0, max: this.height, kind: 'integer' };
        var sitesGenerator = new Stochator(xOrd, yOrd);
        return sitesGenerator.next(this.cellCount);
    };

    CellMap.prototype.getPoints = function() {
        return this.relaxPoints(this.getSeedPoints(), 10);
    };

    CellMap.prototype.getCell = function(index) {
        return {
            centroid: this.centroids[index],
            polygon: this.polygons[index],
            edges: this.edges[index],
            cellType: this.cellTypes[index]
        };
    };

    CellMap.prototype.getCentroid = function(index) {
        return this.centroids[index];
    };

    CellMap.prototype.setMapGeometry = function(width, height) {
        this.width = width, this.height = height;
        this.mask = Util.Geom.createRectangle([0, 0], [this.width, this.height]);
        this.isEdgePoint = Util.Geom.edgeTester(this.width, this.height);
        this.isEdgePolygon = Util.Geom.polygonEdgeTester(this.width, this.height);
    };

    CellMap.prototype.setCellCount = function(cellCount) {
        this.cellCount = cellCount;
        var randomCellGenerator = new Stochator({ min: 0, max: this.cellCount, kind: 'integer' });
        this.getRandomCells = randomCellGenerator.next;
    }

    CellMap.prototype.setCellGeometry = function() {
        var initialPolygons = this.getVoronoiPolygons();
        this.centroids = this.getCentroids(initialPolygons);
        var initialVertices = this.getVertices(initialPolygons);
        this.polygons = this.relaxPolygonVertices(initialPolygons, initialVertices);
        this.vertices = this.getVertices(this.polygons);
    };

    CellMap.prototype.setCellAttributes = function() {
        this.edges = this.getEdges();
        this.cellTypes = this.getCellTypes();
    };

    function CellMap(cellCount, width, height) {
        this.setCellCount(cellCount);
        this.setMapGeometry(width, height);
        this.setCellGeometry();
        this.setCellAttributes();
    }
    return CellMap;
})();
